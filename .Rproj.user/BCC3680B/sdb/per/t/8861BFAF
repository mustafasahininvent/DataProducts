{
    "contents" : "shorten<-function(x,n=0.1){head(tail(sort(x),floor(length(x)*(1-n/2))),floor(length(x)*(1-n)))}\n\ngrupla <- function(sets,PGN){\n  zset<-sets[setType==\"ZSST\",length(unique(productGroup)),by=skuSet][V1!=1][order(V1)]\n  \n  liste<-lapply(zset$skuSet,function(x) sort(unique(sets[setType==\"ZSST\" & skuSet==x]$productGroup)))\n  if(length(liste)>0){\n    nl<- sapply(liste,length)\n    liste<-liste[order(-nl)]\n    nl<- sapply(liste,length)\n    \n    runliste<-oliste<-liste\n    parts<-list(NULL)\n    i<-1\n    while(length(runliste)>0){\n      l<-unlist(head(runliste,1))\n      temp<-NULL\n      repeat{\n        inter<-lapply(runliste,function(x) intersect(x,l))\n        temp<-sort(unique(union(l, unlist(runliste[which(0!=sapply(inter,length))]))))\n        if(length(temp)==length(l))\n          break\n        l<-temp\n      }\n      parts[[i]]<-temp\n      diff<-lapply(runliste,function(x) setdiff(x,parts[[i]]))\n      runliste<-runliste[which(0!=sapply(diff,length))]\n      i<-i+1\n    }\n  } else {\n    parts<-list()\n  }\n    \n  \n  PGN$set<-PGN$nset<-i<-0\n  for(p in parts){\n    i<-i+1\n    PGN[productGroup %in% p]$set<-i\n  }\n  PGNN<-PGN[,list(productGroup,n,set)][order(productGroup)]\n  PGNN$R<-0\n  \n  r<-0;maxpg<-max(PGN[set>0,list(adet=sum(n)),by=set]$adet);maxs<-max(PGNN$set)\n  if(!is.finite(maxpg))\n    maxpg<-sum(PGN$n,na.rm=T)/14\n  while(nrow(PGNN[R==0])>0){ \n    r<-r+1\n    analiz<-PGNN[R==0]\n    if(nrow(analiz[set>0])>0){\n      s<-0;jump<-0\n      while(sum(analiz[R!=0]$n)<maxpg & jump==0){\n        jump<-0\n        s<-s+1\n        if(s<=maxs){\n          if(sum(analiz[R!=0 | set==s]$n)<=maxpg){\n            analiz[set==s]$R<-r \n          } else {\n            jump<-1           \n          }\n        } else {\n          if(sum(analiz[R!=0 | productGroup==min(analiz[R==0]$productGroup)]$n)<maxpg){\n            analiz[productGroup==min(analiz[R==0]$productGroup)]$R<-r\n          } else {\n            jump<-1         \n          }\n        }      \n      }\n    } else {\n      analiz[cumsum(analiz$n)<maxpg]$R<-r\n    }\n    PGNN[productGroup %in% analiz[R==r]$productGroup]$R<-r\n    \n  }\n  return(PGNN)\n}\n\nMode <- function(x) {\n  ux <- unique(x)\n  ux[which.max(tabulate(match(x, ux)))]\n}\nweekeffectswitch <- function(day) {\n  switch(min(1+day,5),\n         1,\n         wMpy$f1,\n         wMpy$f2,\n         wMpy$f3,\n         1)\n}\n\nroundUp <- function(x,to=10)\n{\n  to*(x%/%to + as.logical(x%%to))\n}\ndistDepo<-function(ar,stk,prec=ar,type=1){\n  s<-stk\n  a<-ar\n  whole<-rep(0,length(ar))\n  remain<-rep(0,length(ar))\n  if(stk>=sum(ar)){\n    result<-ar\n  }else{\n    while(trunc(s/sum(a>0))>0){\n      if(type==1)\n        ww<- 1 * (a==max(a))\n      else\n        ww<- 1 * (a>0)\n      a<-a-ww\n      s<-s-sum(ww)\n      whole<- whole + ww \n    }\n    if(s>=1){\n      p=prec*((ar-whole)!=0)\n      remain[order(-p)[1:s]]<-1\n    }\n    result <- whole + remain\n  }\n  return(result)\n}\ndistribute4<-function(depostock,ar,k,prec=ar,type=1){\n  #pred: each ar is multiple of k\n  prec<-(ar>0)*prec\n  k*distDepo(ar/k,depostock/k,prec,type)\n}\n\n\nstokseti<-function(ar,satishizi,int=0.1,profit=0.3){\n  setar=max(ar)\n  return(setar)\n}\n\n\nGunler<-data.table(en=c(\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\")\n                   ,tr=c(\"Pazart\",\"Sal\",\"amba\",\"Per\",\"Cuma\",\"Cum\",\"Pazar\")\n)\n\nfast.date=function(x){as.Date(levels(x))[as.integer(x)]}\n\nPOS2Date=function(x){as.Date(as.character(x))}\n\n\nwrite_ia_ar<-function(DATA){\n  ia_ar<-DATA[productGroup %in% c(103026,304012,304014,315023,523004) & store %in% c(2013,2006,1001,1003,1004,1007,1006,2040,2034,1014,1015)\n              ,list(\n                amount=nar,\n                createOn=date2num(Sys.Date())-2,\n                description=\"deniyor\",\n                replenishOn=date2num(Sys.Date())-1,\n                sku,\n                store\n              )]\n  write.table(ia_ar,\"ia_ar_20140723.csv\",sep=\"|\",row.names=F)\n}\n\n\nwrite_gDATA<-function(){\n  #avgStock hesapli sku, store, avgStock seklinde\n  avgStock<-read.table(choose.files(),header=T,sep=\",\")\n  names(avgStock)[1]<-\"sku\"\n  avgStock<-data.table(avgStock,key=c(\"sku\",\"store\"))\n  setkeyv(DATA,cols=c(\"sku\",\"store\"))\n  DATA[,kolile:= pmax(REORDERP,LEAD*AVGSALE,gap)]\n  gDATA<-DATA[avgStock,nomatch=0]\n  gDATA[,sgs_avgStock:= roundUp(avgStock/AVGSALE,30)]\n  gDATA[,sgs_sip:= roundUp(kolile/AVGSALE,30)]\n  write.table(gDATA,\"gDATA.csv\",sep=\"|\",row.names=F)\n}\n\ngetdata<-function(j){\n  koli<-gap<-LEAD<-AVGSALE<-SDSALE<-SAFETYSTOCK<-REORDERP<-PO<-GAP<-ar<-0\n  OAVGSALE<-OSDSALE<-STOCK<-0\n  avgAmt<-avgAmtSet<-avgHubAmt<-avgHubAmtSet<-avgSum2Amt<-avgSum4Amt<-0\n  avgPrice<-avgPriceSet<-avgHubPrice<-avgHubPriceSet<-avgSum2Price<-avgSum4Price<-0\n  avgTl<-avgTlSet<-avgHubTl<-avgHubTlSet<-avgSum4Tl<-0\n  isNewListedAll<-noneSale<-0\n  depoStock<-\"yeni datada gelecek\"\n  wasProm<-willProm<-\"FNileGeliyor\"\n  sgs<-\"noPOcalc\"\n  war<-\"bakalım\"\n  cost<-\"c\"\n  price<-\"p\"\n  isHub<-\"h\"\n  setMpy<-\"setMpy\"\n  skuDepo<-\"skuDepo\"\n  isNewStocked<-\"isNewStocked\"\n  data<-data.table(j[,list(sku, store,productGroup, supplyStore,supplySource,\n                           isHub,\n                           stock, storeStock,\n                           koli=amountBoxOut,\n                           gap,\n                           LEAD = supplyDays,\n                           OAVGSALE,\n                           OSDSALE,\n                           AVGSALE,\n                           SDSALE,\n                           SAFETYSTOCK,\n                           depoStock,\n                           STOCK2,\n                           STOCK4,\n                           OPENQ,\n                           REORDERP,\n                           PO,\n                           GAP,\n                           ar,     \n                           sgs,\n                           wasProm,\n                           willProm,\n                           avgAmt,\n                           avgAmtSet,\n                           avgHubAmt,\n                           avgHubAmtSet,\n                           #avgPrice,\n                           #avgPriceSet,\n                           #avgHubPrice,\n                           #avgHubPriceSet,\n                           #avgSum4Price,\n                           avgSum2Amt,\n                           avgSum4Amt,\n                           #isNewListed,\n                           #isNewListedAll,\n                           isNewStocked,\n                           noneSale,\n                           vendorDispoWeekdays,\n                           isDispoDay,\n                           cost,\n                           price,\n                           setMpy,\n                           skuDepo\n  )])\n  return(data)\n}\ndecideAR<-function(GAP,koli,AVGSALE,STOCK,OPENQ, cost,tlLimit){\n  if(AVGSALE>0){\n    kackoli=kolile(((GAP)/koli),0.05)\n    while((kackoli*koli+STOCK+OPENQ)/AVGSALE>280 & kackoli>0){\n      kackoli<-kackoli-1\n    }\n    ar=koli*kackoli\n    if(kackoli==0 & AVGSALE>0.3 & (koli+STOCK+OPENQ)/AVGSALE<80){\n      ar<-koli\n    }\n  } else {\n    ar<-koli*kolile(GAP/koli,0.1)\n  }\n  while(!is.na(cost) & ar*cost>=tlLimit & ar-koli>=0){\n    ar<-ar-koli\n  }\n  return(ar)\n}\ngetPOw<-function(osale,STOCK,nAvg=nAvg,serviceLevel=j$serviceLevel,\n                 gap=j$gap,koli=j$amountBoxOut,LEAD=j$supplyDays,OPENQ=j$OPENQ,w=1, cost=j$cost,tlLimit=j$tlLimit, ekLead){\n  \n  OAVGSALE<-mean(tail(osale,nAvg))\n  OSDSALE<-sd(tail(osale,nAvg))\n  \n  OUTSALE=pmin(osale,meanp(osale)+3*sd(osale),na.rm=T)\n  #OUTSALE=ceiling(OUTSALE)\n  \n  AVGSALE=mean(tail(OUTSALE,nAvg))*w  ######\n  SDSALE=sd(tail(OUTSALE,nAvg))\n  if(is.na(SDSALE))\n    SDSALE<-0\n  \n  #   if(j$sku %in% insert$sku)\n  #     data$AVGSALE=data$AVGSALE*1.2\n  z<-qnorm(serviceLevel)\n  z<-qnorm(0.95) ##dikkat bir anda ??kmayal?m diye idi, serv levell?s?na geccez ?st satir\n  \n  \n  minShelf<-ifelse(j$store<7000 & j$store>6000,j$minShelf,0 )\n  \n  #SAFETYSTOCK=z*sqrt(((SDSALE^2)*LEAD)+AVGSALE^2) \n  #REORDERP=ceiling(SAFETYSTOCK+AVGSALE*LEAD)\n  SAFETYSTOCK=z*sqrt(((pmin(5,SDSALE)^2)*LEAD)+AVGSALE^2) \n  REORDERP=(SAFETYSTOCK +minShelf+ AVGSALE*LEAD)\n  \n  if(!((STOCK+OPENQ)<max(REORDERP,gap)) & ekLead!=0 ){\n    \n    LEAD<-LEAD+ekLead\n#     SAFETYSTOCK=z*sqrt(((SDSALE^2)*LEAD)+AVGSALE^2) \n#     REORDERP=ceiling(SAFETYSTOCK+AVGSALE*LEAD)\n    SAFETYSTOCK=z*sqrt(((pmin(5,SDSALE)^2)*LEAD)+AVGSALE^2) \n    REORDERP=(SAFETYSTOCK +minShelf+ AVGSALE*LEAD)\n  }\n  \n  \n  #(STOCK+OPENQ)<=max(REORDERP,gap)\n  if ((STOCK+OPENQ)<max(REORDERP,gap)){\n    PO=AVGSALE*LEAD + (REORDERP-(STOCK+OPENQ))*(AVGSALE*LEAD<=(REORDERP-(STOCK+OPENQ)))\n    GAP=pmax((gap-(STOCK+OPENQ)),PO)\n    GAP=round(GAP)\n    #  kackoli=kolile(((GAP)/koli),0.2)  # koli adeti kysyty ls i çok arttyryyor\n    #  ar=koli*kackoli    \n    ar<-decideAR(GAP,koli,AVGSALE,STOCK,OPENQ, cost,tlLimit)\n  }else{\n    PO<-0\n    GAP<-0\n    ar<-0\n  }\n  sgs<-(ar+STOCK+OPENQ)/AVGSALE\n  return(data.table(OAVGSALE,OSDSALE,AVGSALE,SDSALE,SAFETYSTOCK,REORDERP,PO,GAP,ar,sgs))\n}\nmergeProm<-function(stk){\n  q<-\"select * from _HELP_PROMOTION\"\n  uuu<-sqlQuery(dbhandle,q)\n  uuu<-data.table(uuu,key=\"sku\")\n  uuu[,c(\"promOn\"):=lapply(.SD,fast.date),.SDcols=c(\"promOn\")]\n  \n  #cst<-(cast(uuu,promOn + sku ~ promotionType, value=\"b\")) \n  cst<-(cast(uuu,promOn + sku ~ type, value=\"b\")) #1021 itibari..\n  cst<-data.table(cst,key=\"sku\")\n  cst[is.na(cst)]<-0\n  cst<-cst[,list(isProm=as.numeric(any(as.logical(.SD)))),by = list(promOn,sku)]\n  setkeyv(cst,cols=\"sku\")\n  date<-as.Date.character(max(stk$createOn_skuStk,na.rm=T))\n  skuProm<-cst[,list(wasProm = any(promOn<=date),\n                     willProm = any(promOn>date)),by=\"sku\"]\n  stk<-skuProm[stk]\n  stk$wasProm[is.na(stk$wasProm)]<-0\n  stk$willProm[is.na(stk$willProm)]<-0\n  return(stk)\n}\n\n\nas.Date.numeric <- function(x, origin=\"1970-01-01\", ...)\n{\n  if ((missing(origin) && nargs()==1)\n      || (is.character(origin) && origin==\"1970-01-01\" && nargs()==2))\n    return(structure(as.integer(x), class=\"Date\"))\n  as.Date(origin, ...) + as.integer(x)\n}\n\nfast.date=function(x){\n  if(!is.factor(x)){\n    x<-as.factor(x)\n  }\n  as.Date(levels(x))[as.integer(x)]}\n\nuniquen<-function(data) sapply(data,function(x)length(unique(x)))\n\n# improved list of objects\n.ls.objects <- function (pos = 1, pattern, order.by,\n                         decreasing=FALSE, head=FALSE, n=5) {\n  napply <- function(names, fn) sapply(names, function(x)\n    fn(get(x, pos = pos)))\n  names <- ls(pos = pos, pattern = pattern)\n  obj.class <- napply(names, function(x) as.character(class(x))[1])\n  obj.mode <- napply(names, mode)\n  obj.type <- ifelse(is.na(obj.class), obj.mode, obj.class)\n  obj.prettysize <- napply(names, function(x) {\n    capture.output(print(object.size(x), units = \"auto\")) })\n  obj.size <- napply(names, object.size)\n  obj.dim <- t(napply(names, function(x)\n    as.numeric(dim(x))[1:2]))\n  vec <- is.na(obj.dim)[, 1] & (obj.type != \"function\")\n  obj.dim[vec, 1] <- napply(names, length)[vec]\n  out <- data.frame(obj.type, obj.size, obj.prettysize, obj.dim)\n  names(out) <- c(\"Type\", \"Size\", \"PrettySize\", \"Rows\", \"Columns\")\n  if (!missing(order.by))\n    out <- out[order(out[[order.by]], decreasing=decreasing), ]\n  if (head)\n    out <- head(out, n)\n  out\n}\n\n# shorthand\nlsos <- function(..., n=10) {\n  .ls.objects(..., order.by=\"Size\", decreasing=TRUE, head=TRUE, n=n)\n}\n\nrunning<-function(func=sum,N=10,V,...){\n  #TS: 5/30/14 M. SAHIN\n  #DS: Running F to N length partitions of V\n  n=pmax(0,1+(length(V))-N)\n  R<-vector(mode=\"numeric\",length=n)\n  i=1\n  while(i<=n){\n    R[i]<- func(V[i:(i+N-1)],...)\n    i=i+1\n  }\n  R\n}\n\nrunning2<-function(func=sum,N=10,V,...){\n  #TS: 5/31/14 M. SAHIN\n  #DS: Running F to N length partitions of V when V is a mtrix\n  n=pmax(0,1+(nrow(V))-N)\n  R<-vector(mode=\"numeric\",length=n)#matrix(NA,nrow=n,ncol=ncol(V))\n  i=1\n  while(i<=n){\n    R[i]<- func(V[i:(i+N-1),],...)\n    i=i+1\n  }\n  R\n}\n\naccu=function(actual,forecast){\n  n=length(actual)\n  error=actual-forecast\n  mean=mean(actual)\n  sd=sd(actual)\n  CV=sd/mean\n  AD=abs(actual-mean)\n  R2=1-sum(error^2)/sum((actual-mean)^2)\n  #AdjR2=1-(1-R2)*(n-1)/(n-k-1)\n  DB=sum(diff(error)^2)/sum(error^2)\n  #FE=sqrt(sum(error^2)/(n-k))\n  FBias=sum(error)/sum(actual)\n  MPE=sum(error/actual)/n\n  MAPE=sum(abs(error/actual))/n\n  RMSE=sqrt(sum(error^2)/n)\n  MAD=sum(abs(error))/n\n  MADP=sum(abs(error))/sum(abs(actual))\n  MASE=MAD/mean(abs(diff(actual)))\n  RAE= sum(abs(error))/sum(abs(actual-mean))\n  WMAPE=MAD/mean\n  #l=data.frame(n,mean,sd,CV,AD,R2,DB,FBias,MPE,MAPE,RMSE,MAD,MADP,MASE,RAE,WMAPE,error)\n  l=data.frame(n,mean,sd,CV,R2,DB,FBias,MPE,MAPE,RMSE,MAD,MADP,MASE,RAE,WMAPE)\n  return(l)\n}\n\naccu2=function(V){\n  actual=V[,1]\n  forecast=V[,2]\n  accu(actual,forecast)\n}\n\nspecialeffect<-function(sale,time,l=7){\n  n=length(sale)\n  d=data.frame(avg=as.numeric(NA),avgin=as.numeric(NA),avgout=as.numeric(NA),avgbefore=as.numeric(NA),avgb1=as.numeric(NA),avgb2=as.numeric(NA),avgb3=as.numeric(NA),avgb4=as.numeric(NA)\n               ,avgafter=as.numeric(NA),avga1=as.numeric(NA),avga2=as.numeric(NA),avga3=as.numeric(NA),avga4=as.numeric(NA))\n  if (n!=length(time))\n    return(d)\n  begin=min(which(time==1))\n  if(is.infinite(begin))\n    return(d)\n  last=min(which(rev(time)==1))\n  end=n-ifelse(is.infinite(last),0,last)\n  avg=mean(sale)\n  avgin=mean(sale[time])\n  avgout=mean(sale[!time])\n  avgbefore=ifelse(0<begin-1,mean(sale[1:(begin-1)]),as.numeric(NA))\n  avgafter=ifelse(n>end+1,mean(sale[(end+1):n]),as.numeric(NA))\n  avgb1=ifelse(0<begin-l,mean(sale[begin-1:l]),as.numeric(NA))\n  avgb2=ifelse(0<begin-2*l,mean(sale[begin-(1+l):(2*l)]),as.numeric(NA))\n  avgb3=ifelse(0<begin-3*l,mean(sale[begin-(1+2*l):(3*l)]),as.numeric(NA))\n  avgb4=ifelse(0<begin-4*l,mean(sale[begin-(1+3*l):(4*l)]),as.numeric(NA))\n  avga1=ifelse(n>end+l,mean(sale[end+1:l]),as.numeric(NA))\n  avga2=ifelse(n>end+2*l,mean(sale[end+(1+l):(2*l)]),as.numeric(NA))\n  avga3=ifelse(n>end+3*l,mean(sale[end+(1+2*l):(3*l)]),as.numeric(NA))\n  avga4=ifelse(n>end+4*l,mean(sale[end+(1+3*l):(4*l)]),as.numeric(NA))\n  d=data.frame(avg,avgin,avgout,avgbefore,avgb1,avgb2,avgb3,avgb4,avgafter,avga1,avga2,avga3,avga4)\n  return(d)\n}\n\nrot<-function (v, n) \n{\n  l <- length(v)\n  n <- n%%l\n  if (n == 0) \n    return(v)\n  tmp <- v[(l - n + 1):l]\n  v[(n + 1):l] <- v[1:(l - n)]\n  v[1:n] <- tmp\n  v\n}\n\nallign<-function(V,idx,before=14,after=14,...){\n  #TS: 6/26/14 M. SAHIN\n  #DS: Alligning values in V such that idx are in a row\n  ncol=pmax(0,length(idx))\n  n<-length(V)\n  \n  idxx<-sapply(idx,function(x)x+(before-(0:(1+after+before))))\n  idxx[idxx<=0]<-n+1\n  \n  R<-as.matrix(c(V,NA))[idxx]\n  R<-matrix(R,ncol=ncol)\n  R\n}\n\n# raw.data must have a time column \n# which can be converted to date\nfilldates=function(raw.data,time.min=NULL,time.max=NULL,na.rep=0,step.size=\"day\"){\n  \n  raw.data$time <- as.Date(raw.data$time)\n  \n  sorted.data <- raw.data[order(raw.data$time),]\n  \n  if (is.null(time.min))  time.min <- sorted.data$time[1]\n  if (is.null(time.max))  {\n    data.length <- length(sorted.data$time)\n    time.max <- sorted.data$time[data.length]\n  }\n  \n  # generate a time sequence with 1 month intervals to fill in\n  # missing dates\n  all.dates <- seq(time.min, time.max, by=step.size)\n  \n  # Convert all dates to a data frame. Note that we're putting \n  # the new dates into a column called \"time\" just like the \n  # original column. This will allow us to merge the data.\n  all.dates.frame <- data.frame(list(time=all.dates))\n  \n  # Merge the two datasets: the full dates and original data\n  merged.data <- merge(all.dates.frame, sorted.data, all=T)\n  \n  # The above merge set the new value to NA.\n  # To replace those with a 0, we must first find all the rows\n  # and then assign 0 to them.\n  merged.data$value[which(is.na(merged.data$value))] <- na.rep\n  return(merged.data)\n}\n\nsumn=function(x){ifelse(is.factor(x),length(x),sum(as.numeric(x),na.rm=T))}\nsump=function(x){ifelse(is.factor(x),length(x),sum(as.numeric(x[x>0]),na.rm=T))}\nsumna=function(x){sum(x,na.rm=T)}\nnalocf <- function(S) {\n  L <- !is.na(S)\n  c(S[L][1], S[L])[cumsum(L)+1]\n}\nnanlocf <- function(S) {\n  L <- !is.nan(S)\n  c(S[L][1], S[L])[cumsum(L)+1]\n}\nlocf0 <- function(S) {\n  L <- !S==0\n  c(S[L][1], S[L])[cumsum(L)+1]\n}\nreadkeygraph <- function(prompt)\n{\n  getGraphicsEvent(prompt = prompt, \n                   onMouseDown = NULL, onMouseMove = NULL,\n                   onMouseUp = NULL, onKeybd = onKeybd,\n                   consolePrompt = \"[click on graph then follow top prompt to continue]\")\n  Sys.sleep(0.01)\n  return(keyPressed)\n}\n\nonKeybd <- function(key)\n{\n  keyPressed <<- key\n}\n\nmandel=function(x){\n  line=xline(x)\n  dev=x-line\n  max=which(abs(dev)==max(abs(dev)))[1]\n  #c(xline(x[1:max]), xline(x[max:length(x)])[-1])\n  if(is.na(max)) return(rep(NA,3))\n  else  return(c(max,x[max],dev[max]))\n}\n\nxline=function(x){\n  n=length(x)\n  line=x[1]+((x[n]-x[1])/(n-1))*0:(n-1)\n}\n\n\ngcd <- function(a,b) ifelse (b==0, a, gcd(b, a %% b))\ngcd1 <- function(a) ifelse (a[2]==0, a[1], gcd(a[2], a[1] %% a[2]))\nmeanp <- function(x) mean(x[x>0],na.rm=T)\ngetp <- function(x) x[x>0]\nkolile=function(x,k=0.2) round(x+0.5-k)\n\nnum2date<-function(x) {\n  y=floor(x/10000)\n  m=round(x %% 10000 ,-2)/100\n  d=x %% 100\n  return(as.Date(ISOdate(y,m,d)))\n}\n\ndate2num<-function(x) {\n  x=as.character(x)\n  y=as.integer(substr(x,1,4))*10000\n  m=as.integer(substr(x,6,7))*100\n  d=as.integer(substr(x,9,10))\n  return(y+m+d)\n}\n\ngetvariable<-function(file=\"\",vname=\"\"){\n  env99_9 <- new.env()\n  load(file, env99_9)\n  vname <- get(vname, env99_9)\n  rm(env99_9)\n  return(vname)\n}\n\nchangesep<- function(location=\"G:/\",sep=\",\"){\n  setwd(location)\n  files=list.files(pattern=\"csv$\")\n  for(f in files[1:234]){\n    t=fread(f)\n    write.table(t,f,sep=sep,row.names = FALSE)\n  }\n}\n\n\nKCT_DB_Q1=\"select id, name, declared, dbEnd, DATEDIFF(second, dbStart, dbEnd) duration, (DATEDIFF(millisecond, dbStart, dbEnd) / declared) \nfrom Koctas.dbo.ia_etl_3 \nwhere db = 1\norder by dbEnd;\"\nDB_tables_query=\"SELECT \nt.NAME AS TableName,\ns.Name AS SchemaName,\np.rows AS RowCounts,\nSUM(a.total_pages) * 8 AS TotalSpaceKB, \nSUM(a.used_pages) * 8 AS UsedSpaceKB, \n(SUM(a.total_pages) - SUM(a.used_pages)) * 8 AS UnusedSpaceKB\nFROM \nsys.tables t\nINNER JOIN      \nsys.indexes i ON t.OBJECT_ID = i.object_id\nINNER JOIN \nsys.partitions p ON i.object_id = p.OBJECT_ID AND i.index_id = p.index_id\nINNER JOIN \nsys.allocation_units a ON p.partition_id = a.container_id\nLEFT OUTER JOIN \nsys.schemas s ON t.schema_id = s.schema_id\nWHERE \nt.NAME NOT LIKE 'dt%' \nAND t.is_ms_shipped = 0\nAND i.OBJECT_ID > 255 \nGROUP BY \nt.Name, s.Name, p.Rows\nORDER BY \nt.Name\"\n\n\nKCT_FAZ1=c(101001,  101002,  101006,\t101007,\t101009,\t103001,\t103026,\t105001,\t105002\n           ,\t304006,\t304012,\t304014,\t315001,\t315017,\t315023,\t319011,\t319023,\t319025\n           ,\t321007,\t321032,\t327006,\t329007,\t329015,\t329016,\t331007,\t331017,\t333004\n           ,\t513001,\t513007,\t517001,\t517057,\t523001,\t523009,\t524003,\t524011, 523004)\nKCT_FAZ200 <- c(101001, 101002, 101006, 101007, 101009, 103001, 103026, 105001, \n                105002, 304006, 304012, 304014, 315001, 315017, 315023, 319011, \n                319023, 319025, 321007, 321032, 327006, 329007, 329015, 329016, \n                331007, 331017, 333004, 513001, 513007, 517001, 517057, 523001, \n                523009, 524003, 524011, 523004, 101003, 101004, 101005, 101008, \n                101011, 103002, 103003, 103004, 103005, 103007, 103009, 103010, \n                103011, 105003, 105004, 105005, 105006, 105007, 105008, 105010, \n                105011, 107002, 107003, 107004, 107005, 107006, 107007, 107008, \n                107010, 107011, 107016, 109002, 109003, 109004, 109005, 109006, \n                109007, 109009, 109010, 109014, 109015, 139001, 139002, 139003, \n                139005, 139006, 139009, 139010, 139011, 139012, 139013, 304001, \n                304002, 304003, 304004, 304005, 304007, 304008, 315002, 315003, \n                315004, 315005, 315006, 315007, 315008, 319002, 319003, 319004, \n                319005, 319006, 319007, 319008, 321001, 321002, 321003, 321004, \n                321005, 321006, 321008, 321009, 327001, 327002, 327003, 327004, \n                327005, 327007, 327009, 327010, 327999, 329001, 329003, 329009, \n                329010, 329012, 329013, 329014, 331001, 331002, 331003, 331004, \n                331005, 331006, 331008, 331009, 333001, 333002, 333003, 333005, \n                333006, 333007, 333009, 333010, 333013, 511002, 511003, 511004, \n                511005, 511006, 511007, 511008, 511009, 511010, 511012, 513002, \n                513005, 513006, 513008, 513009, 513010, 513011, 513012, 517002, \n                517003, 517004, 517005, 517006, 517007, 517008, 517009, 523002, \n                523003, 523005, 523006, 523007, 523008, 523010, 524001, 524004, \n                524005, 524006, 524007, 524008, 524009, 524010, 525001, 525002, \n                525003, 525004, 525005, 525006, 525007, 525008, 525009, 525010)\n\nKCT_TEST_STORE<-c(1001,1007,1014,2013,2040)\nKCT_TEST_CONTROL<-c(1003,1004,1006,1015,2006,2034)\nmape<-function(x){\n  sum(abs((x$Forecast-x$Sales)/x$Sales))/length(x$Sales)\n}\nmad<-function(x){\n  mean(abs(x$Forecast-x$Sales))\n}\nmadp<-function(x){\n  sum(abs(x$Forecast-x$Sales))/sum(x$Sales)\n}\n",
    "created" : 1419235580320.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4102069284",
    "id" : "8861BFAF",
    "lastKnownWriteTime" : 1416410826,
    "path" : "G:/Koctas/InventRFunctions.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}